---
title: 'Practical 2: Load and process geographical data in R'
author: David L Miller

---

# Aims

By the end of this practical, you should feel comfortable:

- Loading data from a geodatabase file into R.
- Removing and renaming columns in a `data.frame`.



# Preamble

Load some useful packages:

```{r load-packages, message=FALSE}
library(rgdal)
library(ggplot2)
library(Distance)
library(knitr)
library(dsm)
library(reshape2)
```

# Load and arrange data

To fit our models we require three objects.

  1. The detection function we fitted previously.
  2. The segment data (sometimes called effort data). This tells us how much effort was expended per segment (in this case how far the boat went) and includes the covariates that we want to use to fit our model.
  3. The observation table. This links the observations in the detection function object to the segments.

In R we can use the `rgdal` package to access the geodatabase files generated by ArcGIS (R can also access shapefiles and rasters).

It can be useful in general to see which "layers" are available in the geodatabase, for that we can use the `ogrListLayers()` function:
```{r list-layers}
ogrListLayers("Analysis.gdb")
```

## Segment data

For our analysis the segment data is located in in the "Segment_Centroids" table in the geodatabase. We can import that into R using the `readOGR()` function:
```{r segs-data-load}
segs <- readOGR("Analysis.gdb", layer="Segment_Centroids")
```

To verify we have the right data by plotting. This will give the locations of each segment:
```{r segs-data-plot, fig.width=5, fig.height=5}
plot(segs)
```

We can turn the object into a `data.frame` (so R can better understand it) and then check that it looks like it's in the right format using `head()`:
```{r segs-data-df}
segs <- as.data.frame(segs)
head(segs)
```
As with the distance data, we need to give the columns of the data particular names for them to work with `dsm`:
```{r rename-segs-cols}
segs$x <- segs$POINT_X
segs$y <- segs$POINT_Y
segs$Effort <- segs$Length
segs$Sample.Label <- segs$SegmentID
```

## Observation data

The observation data is exactly what we used to fit out detection function in the previous exercise (though this is not necessarily always true).

```{r obs-data-load}
obs <- readOGR("Analysis.gdb", layer="Sightings")
```

Again we can use a plot to see whether the data looks okay. This time we only have the locations of the observations:
```{r obs-data-plot}
plot(obs)
```

Again, converting the object to be a `data.frame` and checking it's format using `head()`:
```{r obs-data-df}
obs <- as.data.frame(obs)
head(obs)
```

Finally, we need to rename some of the columns:
```{r rename-obs-cols}
obs$distance <- obs$Distance
obs$object <- obs$SightingID
obs$Sample.Label <- obs$SegmentID
obs$size <- obs$GroupSize
```

## Detection functions

We can load the fitted detection function objects that we saved previously.
```{r load-df}
load("df-models.RData")
```
We need to remove the observations at distances greater than the truncation
```{r rm-obs-truncation}
obs <- obs[obs$distance<=df_hn$ddf$meta.data$width,]
```


# Exploratory analysis


```{r make-data}
join_dat <- join(segs, obs, by="Sample.Label", type="full")
n <- ddply(jj, .(Sample.Label), summarise, n=sum(size), .drop = FALSE) 
segs_eda <- segs[sort(segs$Sample.Label),]
segs_eda$n <- n$n

# remove the columns we don't need,
segs_eda$CentreTime <- NULL
segs_eda$POINT_X <- NULL
segs_eda$POINT_Y <- NULL
segs_eda$segment.area <- NULL
segs_eda$off.set <- NULL
segs_eda$CenterTime <- NULL
segs_eda$Effort <- NULL
segs_eda$Length <- NULL
segs_eda$SegmentID <- NULL
segs_eda$coords.x1 <- NULL
segs_eda$coords.x2 <- NULL

# "melt" the data so we have four columns:
#   Sample.Label, n (number of observations),
#   variable (which variable), value (its value)
segs_eda <- melt(segs_eda, id.vars=c("Sample.Label", "n"))
# try head(segs_eda)
```


Finally, we can plot histograms:
```{r}
p <- ggplot(segs_eda)
p <- p + geom_histogram(aes(value, weight=n))
p <- p + facet_wrap(~variable, scale="free")
p <- p + xlab("Covariate value") + ylab("Aggregated estimated abundance")
print(p)
```


These plots give a very rough idea of the relationships we can expect in the model. Notably these plots don't take into account interactions between the variables and potential correlations between the terms, as well as detectability.


# Save the data

We can now save the `data.frame`s that we've created into an `RData` file so we can use them later.

```{r save-models}
save(segs, obs, file="sperm-data.RData")
```

