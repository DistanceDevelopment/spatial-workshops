Introduction to distance sampling
========================================================
author: David L Miller
css: custom.css
transition: none

Overview
====================

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(cache=TRUE, echo=FALSE)
# load the sperm whale data
load("../spermwhale-analysis/df-models.RData")
# remove the fitted models to avoid confusion
rm(df_hr, df_hr_ss)
```

- Line transects
- Simple estimates of abundance
- Why is detectability important?
- What is a detection function?
- First look at fitting models in R


How many animals are there? (500!)
========================================================


```{r, plot}
# code adapted from my RDistance book, converged.yt/RDistanceBook
set.seed(1234) # same results every time
library(mgcv) # for inSide

N <- 500
# generate population locations
x <- runif(N)
y <- runif(N)
# plot it
par(mar=rep(0,4))
plot(x,y, pch=19,asp=1,cex=0.4,main="",col="black", axes=FALSE, xlab="", ylab="")
polygon(x=c(0,1,1,0,0), y=c(0,0,1,1,0))
```

General strategy
========================================================

- Take a sample in some fixed areas
- Find density/abundance in *covered area*
- Multiply up to get abundance

General strategy (What did we assume?)
========================================================

- Take a sample in some fixed areas
  - *Sample is representative*
- Find density/abundance in *covered area*
  - *Estimator is "good"*
- Multiply up to get abundance
  - *Sample is representative*
  
Plot sampling
========================================================
left: 45%

```{r, plotsampling}
par(mar=rep(0,4))
plot(x,y, pch=19,asp=1,cex=0.4,main="",col="black", axes=FALSE, xlab="", ylab="")
polygon(x=c(0,1,1,0,0), y=c(0,0,1,1,0))

# generate some quadrats
set.seed(3111)# same results every time
quadrat <- list(x=c(0,0,0.1,0.1,0),y=c(0,0.1,0.1,0,0))
n <- 0
for(i in 1:10){
  # randomly place a quadrat (and plot it)
  this.quadrat <- quadrat
  this.quadrat$x <- this.quadrat$x + runif(1, 0.1, 0.9)
  this.quadrat$y <- this.quadrat$y + runif(1, 0.1, 0.9)
  polygon(this.quadrat, lty=2, border="blue")
  # see which points are inside
  inout <- inSide(this.quadrat, x, y)
  # count them
  n <- n + sum(inout)
  # plot the points inside the quadrat in red
  points(x[inout], y[inout], pch=19, cex=0.6, col="red")
}
```

***

- Surveyed 10 quadrats (each $0.1^2$ units)
  - Total covered area $a=10 * 0.1^2 =$ `r 10*0.1^2`
- Saw $n=$ `r n` animals
- Estimated density $\hat{D}=n/a=$ `r n/(10*0.1^2)`
- Total area $A=1$
- Estimated abundance $\hat{N}=\hat{D}A=$ `r  n/(10*0.1^2)`



Strip transect
========================================================
left: 45%

```{r strip}
par(mar=rep(0,4))
plot(x,y, pch=19,asp=1,cex=0.4,main="",col="black", axes=FALSE, xlab="", ylab="")
polygon(x=c(0,1,1,0,0), y=c(0,0,1,1,0))

# zero the count from last time
n <- 0

# generate some strips
set.seed(12)
# in this case we don't randomise the offset of the grid
strip <- list(x=c(-0.0125,-0.0125,0.0125,0.0125,-0.0125), y=c(0,1,1,0,0))
strip$x <- strip$x + 0.1
for(i in 1:4){
  # plot the strip and its centreline
  polygon(strip, lty=2, border="blue")
  lines(rep(mean(range(strip$x)),2), c(0,1), col="blue")
  # see what was inside the strip
  inout <- inSide(strip,x,y)
  # count them
  n <- n + sum(inout)
  # plot those animals within the strip
  points(x[inout], y[inout], pch=19, cex=0.6, col="red")
  # calculate next strip location
  strip$x <- strip$x+0.2
}
# covered area -- same area as for the quadrats
covered <- 4*1*0.025
# estimate density
D <- n/covered
# area of the survey region
A <- 1
# estimate abundance
Nhat <- D*A
```

***

- Surveyed 4 lines (each $1*0.025$ units)
  - Total covered area $a=4*1*0.025 =$ `r covered`
- Saw $n=$ `r n` animals
- Estimated density $\hat{D}=n/a=$ `r D`
- Total area $A=1$
- Estimated abundance $\hat{N}=\hat{D}A=$ `r  Nhat`


Detectability
====================================
type: section


Detectability matters!
====================================

- We've assumed certain detection so far
- This rarely happens in the field
- Distance to the **object** is important
  - (Other things too, more on that later)
  - Detectability should decrease with increasing distance

Distance and detectability
=============================

<img src="images/dolphins.jpg" alt="Dolphins near and far from the bow of a ship. Credit Scott and Mary Flanders">

<small>Credit <a href="http://www.nordhavn.com/egret/captains_log_sept11.php">Scott and Mary Flanders</a></small>

Recording distances is more efficient
======================================

- Plots: what if an animal is *just* outside the box?
- Strips: what if an animal is *just* outside the strip?

- Line transects: record **everything** (within reason), then discard later
  - Decide strip width (*truncation distance*) later

Detection as a function of distance
====================================

```{r df}
curve(exp(-x^2/(2*0.01^2)), from=0, to=0.025, xlab="Distance", ylab="Probability of detection")
```

***

- Model probability of detection, given distance
- Fit models for the curve
- Derive a probability of detection from this model

Line transect
========================================================


```{r lt}
par(mar=rep(0,4))
plot(x,y, pch=19,asp=1,cex=0.6,main="",col="black", axes=FALSE, xlab="", ylab="")
polygon(x=c(0,1,1,0,0), y=c(0,0,1,1,0))

# generate some lines
# in this case we don't randomise the offset of the grid
lt <- list(x=c(-0.0125, -0.0125, 0.0125, 0.0125, -0.0125),  y=c(0, 1, 1, 0, 0))
# set sigma
sigma <- 0.01
# storage for detected distances
detected_distances <- c()
for(i in 1:4){
  # calculate next strip location
  lt$x <- lt$x+0.15
  # plot the line transect
  lines(x=rep(mean(range(lt$x)),2), y=c(0,1), col="blue",lty=2)
  # calculate the distances to animals from the line
  distances <- abs(lt$x - x)
  # randomly decide which were detected
  detected <- exp(-distances^2/(2*sigma^2)) > runif(length(distances))
  # plot those animals detected
  points(x[detected], y[detected], pch=19, cex=0.6, col="red")
  # collect the distances to detected objects
  detected_distances <- c(detected_distances, distances[detected])
}
```


Line transects - distances
========================================================

```{r distance-hist}
hist(detected_distances, main="", xlab="Distance",breaks=seq(0,max(detected_distances),len=7))
```
***
- Distances from the **line** (sampler) to animal
- Now we recorded distances, what do they look like?
- "Fold" distribution over, left/right doesn't matter
- Drop-off in # observations w. increasing distance

Distance sampling animation
============================

![Animation of line transect survey](images/distanim.gif)

"You should model that"
====================================
type: section

Detection function
====================================

```{r df-fit}
hist(detected_distances, main="", xlab="Distance",breaks=seq(0,max(detected_distances),len=7), freq=FALSE, ylim=c(0, 85), axes=FALSE, ylab="Probability of detection")
xx <- seq(0, 0.05, len=1000)
lines(xx, exp(-xx^2/(2*sigma^2))/integrate(function(x)  exp(-x^2/(2*sigma^2)), lower=0, upper=0.02)$value)
axis(1)
g0 <- 1/integrate(function(x)  exp(-x^2/(2*sigma^2)), lower=0, upper=0.02)$value
axis(2, at=c(0, g0/2, g0), labels=c(0,0.5,1))
```

Using distance information
==============================

- Detection function: $\mathbb{P}(\text{ detection } \vert \text{ at distance } x)$
- Integrate out the conditioning $\Rightarrow \mathbb{P}(\text{ detection }) = \hat{p}$
- "Inflate" $n$ by $\hat{p}$ to estimate abundance

Integrating out distance
==========================

```{r integrate-dist, results="hide"}
library(animation)

plot_int_dist <- function(){

  g <- function(x) exp(-x^2/(2*0.45^2))
  xvals <- seq(0,1,len=100)
  
  # pre-calculate
  gvals <- g(xvals)
  
  # now plot
  for(i in 1:length(xvals)){
    plot(xvals, gvals, type="n", main="",
         ylab="Probability of detection", xlab="Distance")
    points(xvals[i], gvals[i], pch=19, col="red")
    polygon(x=c(0,xvals[1:i], xvals[i],0),
            y=c(0,gvals[1:i],0,0), col = "grey", border=NA)
    lines(xvals, gvals)
    text(x=0.3, y=0.25, label=expression(integral(g(x)*dx, 0, w)), cex=3)
    
    ani.pause()
  }
}

saveGIF(plot_int_dist(), "integrate-distance.gif", interval = 0.2, ani.width = 500, ani.height = 500)
```

![Integrating out distance](integrate-distance.gif)



Distance sampling estimate
========================================================

```{r calc-Nhat-line}
## calculate Nhat
# calculate mu, since we know sigma and set w=0.02
mu <- integrate(function(x)  exp(-x^2/(2*sigma^2)), lower=0, upper=0.02)$value
# calculate p = mu/w
p <- mu/0.02
n<-length(detected_distances)
covered <- 2*0.02*5
Nhat.lt <- A*n/(covered*p)
```


- Surveyed 5 lines (each $1*0.025$ units)
  - Total covered area $a=5*1*0.02 =$ `r covered`
- Probability of detection $\hat{p} = \int_0^w \frac{g(x)}{w}dx=$ `r round(p,4)`
- Saw $n=$ `r n` animals
- Inflate to $n/\hat{p}=$ `r round(n/p, 3)`
- Estimated density $\hat{D}=\frac{n/\hat{p}}{a}=$ `r round(n/(covered*p), 0)`
- Total area $A=1$
- Estimated abundance $\hat{N}=\hat{D}A=$ `r  round(Nhat.lt, 0)`

Summary: line transects
========================

- Efficient survey design
- Relax the assumption of perfect detection
- Exchange assumptions for data
- More information = better inference

Assumptions
========================
type: section


Assumptions
==========================

1. Animals are distributed independent of lines
2. On the line, detection is certain
3. Distances are recorded correctly
4. Animals don't move before detection

Animals are distributed independent of lines
==========================
left: 60%
```{r lt-assumption-unif}
par(mar=rep(0,4))

nsim<-1000

x_a1 <- sample(c(-1,1),1000,replace = TRUE)*rexp(1000, 1)/50
x_a1 <- x_a1 + 0.15*1:5
y_a1 <- runif(nsim)
inout <- inSide(data.frame(x_a1=c(0,1,1,0,0), y_a1=c(0,0,1,1,0)), x_a1, y_a1)
x_a1 <- x_a1[inout] 
y_a1 <- y_a1[inout]
   
plot(x_a1,y_a1, pch=19,asp=1,cex=0.6,main="",col="black", axes=FALSE, xlab="", ylab="", xlim=c(0,1))
polygon(x=c(0,1,1,0,0), y=c(0,0,1,1,0))

# generate some lines
# in this case we don't randomise the offset of the grid
lt <- list(x=c(-0.0125, -0.0125, 0.0125, 0.0125, -0.0125),  y=c(0, 1, 1, 0, 0))
# set sigma
sigma <- 0.01
# storage for detected distances
detected_distances_c <- c()
for(i in 1:5){
  # calculate next strip location
  lt$x <- lt$x+0.15
  # plot the line transect
  lines(x=rep(mean(range(lt$x)),2), y=c(0,1), col="blue",lty=2)
  # calculate the distances to animals from the line
  distances <- abs(lt$x - x)
  # randomly decide which were detected
  detected <- exp(-distances^2/(2*sigma^2)) > runif(length(distances))
  # plot those animals detected
  points(x[detected], y[detected], pch=19, cex=0.6, col="red")
  # collect the distances to detected objects
  detected_distances_c <- c(detected_distances_c, distances[detected])
}
```
***
- When transects follow features
- Difficult to work out detectability vs. distribution

On the line, detection is certain
====================================

```{r df-g0-issue}
hist(detected_distances, main="", xlab="Distance",breaks=seq(0,max(detected_distances),len=7), freq=FALSE, ylim=c(0, 85), axes=FALSE, ylab="Probability of detection")
xx <- seq(0, 0.05, len=1000)
lines(xx, exp(-xx^2/(2*sigma^2))/integrate(function(x)  exp(-x^2/(2*sigma^2)), lower=0, upper=0.02)$value)
axis(1)
g0 <- 1/integrate(function(x)  exp(-x^2/(2*sigma^2)), lower=0, upper=0.02)$value
axis(2, at=c(0, g0/2, g0), labels=c(0,"???","???"))
```
***
- Perception bias
- Availability bias
- Don't know $y$ axis scale

Perception bias
=================

![Seal peeping out](images/seal-peep.jpg)
<br/>
<br/>
<small>Credit [MAKY_OREL](https://pixabay.com/en/seal-head-water-surface-eye-591292/)</small>
***
![Orca porpoising](images/Orca_porpoising.jpg)
<br/>
<br/>
<small>Credit [Minette Layne](https://commons.wikimedia.org/wiki/File:Orca_porpoising.jpg)</small>


Distances are recorded correctly
====================================

```{r df-measurement-issue}
hist(detected_distances, main="", xlab="Distance",breaks=seq(0,max(detected_distances),len=7), freq=FALSE, ylim=c(0, 85), axes=FALSE, ylab="Probability of detection")
xx <- seq(0, 0.05, len=1000)
lines(xx, exp(-xx^2/(2*sigma^2))/integrate(function(x)  exp(-x^2/(2*sigma^2)), lower=0, upper=0.02)$value)
axis(1, at=seq(0,max(detected_distances), len=7), labels=rep("???", 7))
g0 <- 1/integrate(function(x)  exp(-x^2/(2*sigma^2)), lower=0, upper=0.02)$value
axis(2, at=c(0, g0/2, g0), labels=c(0,0.5,1))
```
***
- Measurement error
- Don't know $x$ axis scale
- This can be systematic


Animals don't move before detection
====================================
left: 60%
```{r lt-assumption-movement}
par(mar=rep(0,4))

plot(x, y, pch=19,asp=1,cex=0.6,main="",col="grey", axes=FALSE, xlab="", ylab="", xlim=c(0,1))
polygon(x=c(0,1,1,0,0), y=c(0,0,1,1,0))

# generate some lines
# in this case we don't randomise the offset of the grid
lt_x <- 0
# set sigma
sigma <- 0.025
for(i in 1:5){
  # calculate next strip location
  lt_x <- lt_x+0.15
  # plot the line transect
  lines(x=rep(mean(range(lt_x)),2), y=c(0,1), col="blue",lty=2)
  # calculate the distances to animals from the line
  distances <- abs(lt_x - x)
  # randomly decide which were detected
  detected <- exp(-distances^2/(2*sigma^2)) > runif(length(distances))
  
  # this is causally backwards, but much easier to program
  # move them
  # plot those animals detected
  for(i in 1:sum(detected)){
    moved_x <- runif(1, min(lt_x, x[detected][i]), 
                        max(lt_x, x[detected][i]))
    moved_y <- y[detected][i] + runif(1, -0.01,0.01)
    points(moved_x, moved_y, pch=19, cex=0.6, col="red")
    arrows(x1=moved_x,
           x0=x[detected][i], 
           y1=moved_y, 
           y0=y[detected][i],
           length=0.05)
  }
}
```
***
- Animals can be attracted or repelled
- Problems with distribution wrt line and/or measurement error

Attraction to the line
========================

<img src="images/dolphins-bowriding.jpg" alt="Dolphins bowriding. Credit Cork Whale Watch.">


<small>Credit [Cork Whale Watch](http://www.corkwhalewatch.com/whale-watching-in-west-cork/)</small>


Detection functions
====================================
type: section


What are detection functions?
========================================================

- Model $\mathbb{P}\left( \text{detection } \vert \text{ animal at distance } x \right)$
- (Hence the integration)
- Many different forms, depending on the data
- All share some characteristics


Detection function assumptions
================================

- Have a "shoulder"
  - *we see things nearby easily*
- Monotonic decreasing
  - *never increasing with increasing distance*
- "Model robust"
  - *lots of forms/flexible models*
- "Pooling robust"
  - *individual heterogeneity averages out*
- "Efficient"
  - *models don't need lots of parameters*


Possible detection functions
=============================

- There are many options
- A restricted set we'll cover in this course...
  - Half-normal
  - Hazard-rate
  - adjustments to the above

Half-normal detection functions
================================

```{r df-hn}
curve(exp(-x^2/(2*0.01^2)), from=0, to=0.025, xlab="Distance", ylab="Probability of detection")
```


Hazard-rate detection functions
================================

```{r df-hr}
curve(1-exp(-(x/0.005)^(-2.5)), from=0, to=0.025, xlab="Distance", ylab="Probability of detection")
```

Adjustment terms
==================

- These models are flexible
- What about adding more flexibilty by "adjusting" them
- Options:
  - Cosine series
  - Polynomials
  - Hermite polynomials
- Add extra flexibility

Half-normal (with cosine adjustments)
=====================================


```{r df-hn-cos, fig.width=12}
par(mfrow=c(1,2))
curve(exp(-x^2/(2*0.01^2)), from=0, to=0.025, xlab="Distance", ylab="Probability of detection", main="Half-normal")
g <- function(x) exp(-x^2/(2*0.01^2))*(1+0.5*cos((2*pi*x)/0.025))
f <- function(x) g(x)/g(0)
curve(f, from=0, to=0.025, xlab="Distance", ylab="Probability of detection", main="Half-normal with 1 cosine adjustment")
```



Okay, but how can we actually do this?
===========================================
type: section

Modelling strategy
=============================

1. Pick some formulations, fit models
2. Check assumptions are violated
3. Goodness of fit
4. Select models
5. Estimate $\hat{N}$ (and uncertainty!)


Distance sampling data
========================

- Need to have data setup a certain way
  - a `data.frame` with one row per observation
  - at least 2 columns, named "`object`" and "`distance`"

```{r}
head(distdata[,c("distance","object","size", "SeaState")])
```

Fitting detection functions (in R!)
============================

- Using the package `Distance`
- Function `ds()` does most of the work

```{r echo=TRUE}
library(Distance)
df_hn <- ds(distdata, truncation=6000, adjustment = NULL)
df_hr <- ds(distdata, truncation=6000, key="hr", adjustment = NULL)
```

Model summary
================

```{r echo=TRUE}
summary(df_hn)
```

Plotting models
================

```{r fig.width=13}
par(mfrow=c(1,2))
plot(df_hn, showpoints=FALSE)
plot(df_hr, showpoints=FALSE)
```

Truncation
============

```{r trunc}
hist(distdata$distance, xlab="Distance (m)", main="")
```
***
- We set `truncation=6000`, why?
- Remove observations in the tail of the distribution
- **Care about $g$ near 0!**
- Trade-off! (Here we use ~96% of the data)
- Len Thomas suggests $g(w)\approx 0.15$


Recap
========
type: section



Distance sampling
======================

- More efficient sampling 
  - No census
- Collect additional information
  - Distances
- Estimate detection
- Use $\mathbb{P}(\text{detection})$ to correct counts


What's next?
=============

- Model checking and selection
- Estimating abundance in R
- Stratification
- What else affects detectability?
