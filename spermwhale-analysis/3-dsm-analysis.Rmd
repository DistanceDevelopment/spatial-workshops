---
title: Density surface models
author: David L Miller

---

# Load some data and packages

```{r load-data-packages}
library(Distance)
library(dsm)
library(ggplot2)
library(knitr)
load("sperm-data.RData")
load("df-models.RData")
```

# Fit some models

General strategy here is to try to models with bivariate location term and separate additive terms and compare. May also be interesting to fit models with environmental covariates in them only (no location terms).

## Quasi-Poisson

*Need to warn folks here about fitting linear terms (and terms that up tick) for prediction/extrapolation.*


```{r fit-models-qp-xy}
k2 <- 30
k1 <- 10

dsm.qp.xy <- dsm(count~s(x, y, k=k2, bs="ts")+
                           s(Depth, k=k1, bs="ts")+
#                           s(DistToCAS, k=k1, bs="ts")+
                           s(SST, k=20, bs="ts")+
#                           s(EKE, k=k1, bs="ts")+
                           s(NPP, k=k1, bs="ts"),
                     family=quasipoisson(),
                     df_hr, segs, obs, method="REML")
summary(dsm.qp.xy)
```

Checking plots don't look great:

```{r qp-check-xy, fig.width=6, fig.height=6}
gam.check(dsm.qp.xy)
```

Plot the estiamted smooth effects:

```{r qp-plot-xy, fig.width=6, fig.height=6}
plot(dsm.qp.xy, pages=1, scale=0)
```

Now the model with the separate terms for `x` and `y`.

```{r fit-models-qp}
dsm.qp <- dsm(count~s(x, k=k1, bs="ts")+
                    s(y, k=k1, bs="ts")+
                    s(Depth, k=k1, bs="ts")+
#                    s(DistToCAS, k=k1, bs="ts")+
                    s(SST, k=20, bs="ts"),#+
#                    s(EKE, k=k1, bs="ts"),#+
#                    s(NPP, k=k1, bs="ts"),
              family=quasipoisson(),
              df_hr, segs, obs, method="REML")
summary(dsm.qp)
```


Note that NPP goes out first when `x` and `y` are additive, but stays in for bivariate terms.

Checking plot again don't look great here

```{r qp-check, fig.width=6, fig.height=6}
gam.check(dsm.qp)
```

Plot the smooths:

```{r qp-plot, fig.width=6, fig.height=6}
plot(dsm.qp, pages=1, scale=0)
```


## Tweedie

Now doing the same procedure with Tweedie...

`DistToCAS` and `NPP` here give good examples of `bs="ts"` working.

```{r fit-models-tw-xy}
dsm.tw.xy <- dsm(count~ s(x,y, k=k2, bs="ts")+
                         s(Depth, k=k1, bs="ts"),#+
#                         s(DistToCAS, k=k1, bs="ts")+
#                         s(SST, k=k1, bs="ts")+
#                         s(EKE, k=k1, bs="ts"),#+
#                         s(NPP, k=k1, bs="ts"),
               family=tw(),
               df_hr, segs, obs, method="REML")
summary(dsm.tw.xy)
```

```{r tw-check-xy, fig.width=6, fig.height=6}
gam.check(dsm.tw.xy)
```

```{r tw-plot-xy, fig.width=8, fig.height=6}
plot(dsm.tw.xy, pages=1, scale=0)
```

```{r fit-models-tw}
dsm.tw <- dsm(count~ #s(x, k=k1, bs="ts")+
#                         s(y, k=k1, bs="ts")+
                         s(Depth, k=k1, bs="ts")+
#                         s(DistToCAS, k=k1, bs="ts")+
#                         s(SST, k=k1, bs="ts")+
#                         s(EKE, k=k1, bs="ts")+
                         s(NPP, k=k1, bs="ts"),
               family=tw(),
               df_hr, segs, obs, method="REML")
summary(dsm.tw)
```

```{r tw-check, fig.width=6, fig.height=6}
gam.check(dsm.tw)
```

```{r tw-plot, fig.width=8, fig.height=6}
plot(dsm.tw, pages=1, scale=0)
```

## Negative binomial


Now again going through all that for negative binomial:

```{r fit-models-nb-xy}
dsm.nb.xy <- dsm(count~s(x,y, k=k2, bs="ts")+
                        s(Depth, k=k1, bs="ts"),#+
#                        s(DistToCAS, k=k1, bs="ts")+
#                        s(SST, k=k1, bs="ts")+
#                        s(EKE, k=k1, bs="ts"),#+
#                        s(NPP, k=k1, bs="ts"),
               family=nb(),
               df_hr, segs, obs, method="REML")
summary(dsm.nb.xy)
```

```{r nb-check-xy, fig.width=6, fig.height=6}
gam.check(dsm.nb.xy)
```

```{r nb-plot-xy, fig.width=8, fig.height=6}
plot(dsm.nb.xy, pages=1, scale=0)
```


```{r fit-models-nb}
dsm.nb <- dsm(count~#s(x, k=k2, bs="ts")+
                        s(y, k=k2, bs="ts")+
                        s(Depth, k=k1, bs="ts"),#+
#                        s(DistToCAS, k=k1, bs="ts")+
#                        s(SST, k=k1, bs="ts")+
#                        s(EKE, k=k1, bs="ts"),#+
#                        s(NPP, k=k1, bs="ts"),
               family=nb(),
               df_hr, segs, obs, method="REML")
summary(dsm.nb)
```

```{r nb-check, fig.width=6, fig.height=6}
gam.check(dsm.nb)
```

```{r nb-plot, fig.width=8, fig.height=6}
plot(dsm.nb, pages=1, scale=0)
```



## Model summary

Quick function to generate model results tables with appropriate summary statistics:

*This should probably get distributed with the workshop materials.*

```{r summarize-models}
summarize_dsm <- function(model){

  summ <- summary(model)

  data.frame(response = model$family$family,
             terms    = paste(rownames(summ$s.table), collapse=", "),
             AIC      = AIC(model),
             REML     = model$gcv.ubre,
             "Deviance explained" = paste0(round(summ$dev.expl*100,2),"%")
            )

}
library(plyr)
summary_table <- ldply(list(dsm.qp,
                            dsm.qp.xy,
                            dsm.tw,
                            dsm.tw.xy,
                            dsm.nb,
                            dsm.nb.xy),
                        summarize_dsm)
summary_table <- as.data.frame(summary_table)
row.names(summary_table) <- c("`dsm.qp`",
                              "`dsm.qp.xy`",
                              "`dsm.tw`",
                              "`dsm.tw.xy`",
                              "`dsm.nb`",
                              "`dsm.nb.xy`")
```

```{r print-table, results="asis"}
summary_table <- summary_table[order(summary_table$REML, decreasing=TRUE),]
kable(summary_table)
```

## Final models

Let's look at all the Q-Q plots together and see which one looks the most favourable:

```{r plot-qq}
par(mfrow=c(2,3))
qq.gam.p <- function(x){qq.gam(x, main=paste0(substitute(x)))}
qq.gam.p(dsm.qp)
qq.gam.p(dsm.qp.xy)
qq.gam.p(dsm.tw)
qq.gam.p(dsm.tw.xy)
qq.gam.p(dsm.nb)
qq.gam.p(dsm.nb.xy)
```

Seems like we can immediately throw out the quasi-Poisson models here.

Comparing the depth terms we see a similar story for every model, a peak at around 1500m:

```{r depth-plots, fig.width=5, fig.height=8}
par(mfrow=c(3,2))
plot_depth <- function(model){
  plot(model, select=which(grepl("Depth", unlist(strsplit(as.character(terms(model$formula)[[3]]), "\\+"))))-1, scale=0, main=paste0(substitute(model)))
  }
plot_depth(dsm.qp)
plot_depth(dsm.qp.xy)
plot_depth(dsm.tw)
plot_depth(dsm.tw.xy)
plot_depth(dsm.nb)
plot_depth(dsm.nb.xy)
```

## "Best" model

If we throw away the quasi-Poisson models, we are left with negative binomial and Tweedie. We throw out `dsm.tw.xy` as it has the next poorest Q-Q plot. It seems like the negative binomial models have better goodness of fit than the Tweedie models, though all have roughly the same REML scores and % deviance explained.

We therefore prefer `dsm.nb.xy` but save all models for use later.


```{r save-models}
save(dsm.qp,
     dsm.qp.xy,
     dsm.tw,
     dsm.tw.xy,
     dsm.nb,
     dsm.nb.xy,
     k1, k2,
     file="count-models.RData")
```
