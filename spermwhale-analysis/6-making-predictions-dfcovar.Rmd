---
title: Making predictions (detection function with covars)
author: David L Miller

---

# Predictions within the study area

Now we've fitted some models, let's use the `predict` functions and the data from GIS to make predictions of abundance.

## Loading the data

```{r load-packages}
library(mgcv)
library(raster)
library(ggplot2)
library(dsm)
library(viridis)
```

```{r load-models}
load("abundance-est-models.RData")
```

First need to load the variables into a "stack" from their files on disk.
```{r preddata}
predictorStack <- stack(c("Covariates_for_Study_Area/Depth.img","Covariates_for_Study_Area/GLOB/CMC/CMC0.2deg/analysed_sst/2004/20040601-CMC-L4SSTfnd-GLOB-v02-fv02.0-CMC0.2deg-analysed_sst.img","Covariates_for_Study_Area/VGPM/Rasters/vgpm.2004153.hdf.gz.img"))
names(predictorStack) <- c("Depth","SST","NPP")
```

Now these are loaded, we can coerce the stack into something `dsm` can talk to via the `as.data.frame` function. Note we need the `xy=TRUE` to ensure that `x` and `y` are included in the prediction data. We also set the offset value.

```{r dataframeandoffset}
predgrid <- as.data.frame(predictorStack, xy=TRUE)
predgrid$off.set <- (10*1000)^2
```

We can then predict for the model `dsm.nb.xy`:
```{r makepred1}
pp <- predict(dsm.nb.xy, predgrid)
```
This is just a list of numbers -- the predictions per cell. We can sum these to get the estimated abundance for the study area:
```{r predsum}
sum(pp)
```
We can also plot this to get a spatial representation of the predictions:
```{r predsp}
predgrid$Nhat <- pp
predgrid <- predgrid[!is.na(predgrid$Nhat),]
p <- ggplot(predgrid)
p <- p + geom_tile(aes(x=x, y=y, fill=Nhat, width=10*1000, height=10*1000))
p <- p + coord_equal()
p <- p + scale_fill_viridis()
print(p)
```


## Predictions for all models

```{r make-preds-enmasse}
# make a list of models
model_list <- list(dsm.nb, dsm.nb.xy, dsm.qp, dsm.qp.xy, dsm.tw, dsm.tw.xy)
# give the list names for the models, so we can identify them later
names(model_list) <- c("dsm.nb", "dsm.nb.xy", "dsm.qp", "dsm.qp.xy", "dsm.tw", "dsm.tw.xy")

# use lapply to calculate the predictions for each fo the models in the list
per_model_Nhat <- lapply(model_list, function(model) predict(model, predgrid))
# sum for each model to give the overall abundance
allmodels_Nhat <- lapply(per_model_Nhat, sum, na.rm=TRUE)

# now make a big prediction data.frame for plotting
big_pred <- predgrid[rep(1:nrow(predgrid),6),]
big_pred$Nhat <- unlist(per_model_Nhat)
big_pred$model_id <- rep(names(model_list), rep(nrow(predgrid),6))
```

What were the total abundances per model?
```{r}
allmodels_Nhat
```

Again we see that the quasi-Poisson is predicting almost an order of magnitude more than the other models.


```{r plotall, fig.width=8, fig.height=8}
big_pred <- big_pred[!is.na(big_pred$Nhat),]
p <- ggplot(big_pred)
p <- p + geom_tile(aes(x=x, y=y, fill=Nhat, width=10*1000, height=10*1000))
p <- p + facet_wrap(~model_id)
p <- p + coord_equal()
p <- p + scale_fill_viridis()
print(p)
```

This plot sucks because the quasi-Poisson models throw out the scale, let's throw them out...

```{r plotsome, fig.width=8, fig.height=8}
big_pred <- big_pred[!(big_pred$model_id %in% c("dsm.qp","dsm.qp.xy")),]
p <- ggplot(big_pred)
p <- p + geom_tile(aes(x=x, y=y, fill=Nhat, width=10*1000, height=10*1000))
p <- p + facet_wrap(~model_id, nrow=3)
p <- p + coord_equal()
p <- p + scale_fill_viridis()
print(p)
```

